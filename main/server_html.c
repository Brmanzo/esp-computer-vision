
#include <stddef.h>

const char INDEX_HTML[] = 
"<!doctype html>"
"<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">"
"<style>"
"  body{margin:0;background:#111;display:grid;place-items:center;height:100vh}"
"  canvas{image-rendering:pixelated;"
"          max-width:100vw; max-height:100vh; display:block}"
"</style>"
"<canvas id=\"c\"></canvas>"
"<script>"
"(async function(){"
"    const canvas = document.getElementById('c');"
"    const ctx = canvas.getContext('2d', { alpha: false });"
"    ctx.imageSmoothingEnabled = false;"
"    const PALETTE = ["
"        [0,   0,   0  ],"
"        [85,  85,  85 ],"
"        [170, 170, 170],"
"        [255, 255, 255]"
"    ];"
"    async function fetchAndDraw() {"
"        const resp = await fetch('/frame?' + Date.now());"
"        if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);"
"        const buf = await resp.arrayBuffer();"
"        const view = new Uint8Array(buf);"
"        if (view.length < 8) throw new Error('Frame missing header');"
"        if (view[0] !== 0xFF || view[1] !== 0x01 || view[6] !== 0xFF || view[7] !== 0x02) {"
"            throw new Error('Header mismatch or corrupted: ' + "
"                [view[0],view[1],view[6],view[7]].map(x=>x.toString(16)).join(' '));"
"        }"
"        const h = (view[2] << 8) | view[3];"
"        const w = (view[4] << 8) | view[5];"
"        const pixelOffset = 8;"
"        const pixels = w * h;"
"        const expectedBytes = Math.ceil(pixels / 4);"
"        if (view.length < pixelOffset + expectedBytes) {"
"            throw new Error(`Not enough pixel data: need ${expectedBytes} bytes, have ${view.length - pixelOffset}`);"
"        }"
"        canvas.width = w;"
"        canvas.height = h;"
"        const imageData = ctx.createImageData(w, h);"
"        const out = imageData.data;"
"        for (let i = 0; i < pixels; ++i) {"
"            const byteIndex = pixelOffset + Math.floor(i / 4);"
"            const withinByte = i % 4;"
"            const shift = (3 - withinByte) * 2;"
"            const value = (view[byteIndex] >> shift) & 0x03;"
"            const base = i * 4;"
"            const RGB = PALETTE[value];"
"            out[base + 0] = RGB[0];"
"            out[base + 1] = RGB[1];"
"            out[base + 2] = RGB[2];"
"            out[base + 3] = 255;"
"        }"
"        ctx.putImageData(imageData, 0, 0);"
"        const vw = window.innerWidth;"
"        const vh = window.innerHeight;"
"        const scaleX = Math.floor(vw / w) || 1;"
"        const scaleY = Math.floor(vh / h) || 1;"
"        const scale = Math.max(1, Math.min(scaleX, scaleY));"
"        canvas.style.width = (w * scale) + 'px';"
"        canvas.style.height = (h * scale) + 'px';"
"    }"
"    async function tick() {"
"        try {"
"            await fetchAndDraw();"
"        } catch (err) {"
"            console.error('frame decode error:', err);"
"        }"
"    }"
"    await tick();"
"    setInterval(tick, 1000);"
"})();"
"</script>";

const size_t INDEX_HTML_LEN = sizeof(INDEX_HTML) - 1; // exclude terminating NUL