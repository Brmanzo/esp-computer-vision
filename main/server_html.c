
#include <stddef.h>

const char INDEX_HTML[] = 
"<!doctype html>"
"<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">"
"<style>"
"  body{margin:0;background:#111;display:grid;place-items:center;height:100vh}"
"  canvas{image-rendering:pixelated;"
"          max-width:100vw; max-height:100vh; display:block}"
"</style>"
"<canvas id=\"c\"></canvas>"
"<script>"
"(async function(){"
"    const canvas = document.getElementById('c');"
"    const ctx = canvas.getContext('2d', { alpha: false });"
"    ctx.imageSmoothingEnabled = false;"
"    const PALETTE = ["
"        [0,   0,   0  ],"
"        [85,  85,  85 ],"
"        [170, 170, 170],"
"        [255, 255, 255]"
"    ];"
"    async function fetchAndDraw() {"
"        const resp = await fetch('/frame?' + Date.now());"
"        if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);"
"        const buf = await resp.arrayBuffer();"
"        const view = new Uint8Array(buf);"
"        if (view.length < 8) throw new Error('Frame missing header');"
"        if (view[0] !== 0xFF || view[1] !== 0x01 || view[8] !== 0xFF || view[9] !== 0x02) {"
"            throw new Error('Header mismatch or corrupted: ' + "
"                [view[0],view[1],view[6],view[7]].map(x=>x.toString(16)).join(' '));"
"        }"
"        const h = (view[2] << 8) | view[3];"
"        const w = (view[4] << 8) | view[5];"
"        const rleLen = (view[6] << 8) | view[7];"
"        if (view[8] !== 0xFF || view[9] !== 0x02) {"
"          throw new Error('Header end marker missing');"
"        }"
"        const DATA_START = 10;"
"        const pixels = w * h;"
"        if (view.length < DATA_START + rleLen + 2) {"
"          throw new Error(`Frame truncated: need ${DATA_START + rleLen + 2}, got ${view.length}`);"
"        }"
"        canvas.width = w; canvas.height = h;"
"        const imageData = ctx.createImageData(w, h);"
"        const out = imageData.data;"
"        let pixelIndex = 0;"
"        for (let i = 0; i < rleLen; ++i) {"
"          const b = view[DATA_START + i];"
"          const count = (b >> 2) & 0x3F;"
"          const color = b & 0x03;"
"          const RGB = PALETTE[color];"
"          for (let j = 0; j < count && pixelIndex < pixels; ++j) {"
"            const base = pixelIndex * 4;"
"            out[base+0] = RGB[0];"
"            out[base+1] = RGB[1];"
"            out[base+2] = RGB[2];"
"            out[base+3] = 255;"
"            ++pixelIndex;"
"          }"
"        }"
"        ctx.putImageData(imageData, 0, 0);"
"        const vw = window.innerWidth;"
"        const vh = window.innerHeight;"
"        const scaleX = Math.floor(vw / w) || 1;"
"        const scaleY = Math.floor(vh / h) || 1;"
"        const scale = Math.max(1, Math.min(scaleX, scaleY));"
"        canvas.style.width = (w * scale) + 'px';"
"        canvas.style.height = (h * scale) + 'px';"
"    }"
"    async function tick() {"
"        try {"
"            await fetchAndDraw();"
"        } catch (err) {"
"            console.error('frame decode error:', err);"
"        }"
"    }"
"    await tick();"
"    setInterval(tick, 1000);"
"})();"
"</script>";

const size_t INDEX_HTML_LEN = sizeof(INDEX_HTML) - 1; // exclude terminating NUL