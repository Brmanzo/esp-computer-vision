<!-- server.html -->
<!-- Bradley Manzo 2026 -->

<!doctype html>
<meta name=\viewport\ content=\width=device-width,initial-scale=1\>
<style>
  body{margin:0;background:#111;display:grid;place-items:center;height:100vh}
  #dbg{color:#9f9;font:12px/1.3 monospace;white-space:pre-wrap;max-width:96vw;margin-top:8px}
  canvas{image-rendering:pixelated;max-width:100vw;max-height:90vh;display:block}
</style>
<canvas id=\c\></canvas>
<pre id=\dbg\>bootâ€¦</pre>
<script>
(async function(){
  const canvas = document.getElementById('c');
  const dbg = document.getElementById('dbg');
  const ctx = canvas.getContext('2d', { alpha: false });
  ctx.imageSmoothingEnabled = false;
  const PALETTE = [[0,0,0],[255,255,255]];
  const DATA_START = 10;
  function hex2(x){ return x.toString(16).padStart(2,'0'); }

  async function fetchAndDraw(){
    const resp = await fetch('/frame?' + Date.now(), { cache: 'no-store' });
    if(!resp.ok) throw new Error('Fetch failed: ' + resp.status);
    const buf = await resp.arrayBuffer();
    const view = new Uint8Array(buf);
    if(view.length < DATA_START + 2) throw new Error('Frame too short: ' + view.length);

    if(view[0] !== 0xFF || view[1] !== 0x01 || view[8] !== 0xFF || view[9] !== 0x02){
      throw new Error('Header mismatch: ' + hex2(view[0])+' '+hex2(view[1])+' '+hex2(view[8])+' '+hex2(view[9]));
    }

    const h = (view[2] << 8) | view[3];
    const w = (view[4] << 8) | view[5];
    const payloadLen = (view[6] << 8) | view[7];
    const need = DATA_START + payloadLen + 2;
    if(view.length < need){
      throw new Error('Frame truncated: need ' + need + ', got ' + view.length);
    }

    dbg.textContent = 'ok w=' + w + ' h=' + h + ' payloadLen=' + payloadLen + ' total=' + view.length;

    canvas.width = w; canvas.height = h;
    const imageData = ctx.createImageData(w, h);
    const out = imageData.data;
    const pixels = w * h;

    let pixelIndex = 0;
    for(let i = 0; i < payloadLen && pixelIndex < pixels; i++){
      const b = view[DATA_START + i];
      for(let bit = 0; bit < 8 && pixelIndex < pixels; bit++){
        const color = (b >> bit) & 1;   // LSB-first (matches your C packer)
        const RGB = PALETTE[color];
        const base = pixelIndex * 4;
        out[base+0] = RGB[0];
        out[base+1] = RGB[1];
        out[base+2] = RGB[2];
        out[base+3] = 255;
        pixelIndex++;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const scaleX = Math.floor(vw / w) || 1;
    const scaleY = Math.floor(vh / h) || 1;
    const scale = Math.max(1, Math.min(scaleX, scaleY));
    canvas.style.width = (w * scale) + 'px';
    canvas.style.height = (h * scale) + 'px';
  }

  async function tick(){
    try{ await fetchAndDraw(); }
    catch(err){ dbg.textContent = 'ERR: ' + err.message; console.error(err); }
  }

  await tick();
  setInterval(tick, 1000);
})();
</script>